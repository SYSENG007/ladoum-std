# Pedigree V1 â€” Sprint 1: Core Foundation

**Date:** 1er janvier 2026, 15:40  
**Status:** âœ… TERMINÃ‰  
**DurÃ©e:** ~30 minutes

---

## ğŸ¯ OBJECTIFS SPRINT 1

CrÃ©er les fondations du systÃ¨me de sÃ©lection V1:
1. âœ… Hook de sÃ©lection (`usePedigreeSelection`)
2. âœ… Utilitaires graphe (`pedigreeGraph.ts`)
3. âœ… SystÃ¨me highlight (`pedigreeHighlight.ts`)
4. âœ… Composant contrÃ´les (`SelectionControls.tsx`)

---

## ğŸ“¦ LIVRABLES

### 1. `usePedigreeSelection.ts`

**Hook React pour gÃ©rer la sÃ©lection:**

```typescript
const {
  selection,          // Set<string> - IDs sÃ©lectionnÃ©s
  selectionMode,      // 'none' | 'single' | 'multiple'
  selectOne,          // (id) => void
  selectMultiple,     // (ids[]) => void
  toggleSelection,    // (id) => void - pour Ctrl+clic
  clearSelection,     // () => void
  isSelected,         // (id) => boolean
} = usePedigreeSelection();
```

**FonctionnalitÃ©s:**
- âœ… SÃ©lection simple (clic)
- âœ… SÃ©lection multiple (Ctrl+clic toggle)
- âœ… Clear selection
- âœ… Mode automatique (none/single/multiple)

---

### 2. `pedigreeGraph.ts`

**Algorithmes de graphe pour pedigree:**

```typescript
// Structure de donnÃ©es
interface PedigreeGraph {
  descendants: Map<string, Set<string>>;  // parent â†’ enfants
  ancestors: Map<string, Set<string>>;    // enfant â†’ parents
  allIds: Set<string>;                    // tous les IDs
}

// Fonctions principales
buildPedigreeGraph(animals): PedigreeGraph
getAncestors(id, graph, maxGen): Set<string>
getDescendants(id, graph, maxGen): Set<string>
findCommonAncestors(ids[], graph): Set<string>
getVisibleNodes(selection, graph): Set<string>
calculateGenerationDepth(id, graph): number
```

**Algorithmes:**
- âœ… Construction graph bidirectionnel (O(n))
- âœ… TraversÃ©e ancÃªtres (BFS avec limite gÃ©nÃ©rations)
- âœ… TraversÃ©e descendants (BFS)
- âœ… Intersection ancÃªtres communs
- âœ… Calcul nÅ“uds visibles selon sÃ©lection

---

### 3. `pedigreeHighlight.ts`

**SystÃ¨me de mise en Ã©vidence visuelle:**

```typescript
// Ã‰tats visuels possibles
type NodeHighlightState = 
  | 'selected'          // SÃ©lectionnÃ© (opacity 1.0, stroke bold)
  | 'common_ancestor'   // AncÃªtre commun (opacity 1.0, dashed, yellow)
  | 'direct_relation'   // Parent/enfant direct (opacity 0.9)
  | 'visible'           // Visible indirect (opacity 0.6)
  | 'hidden';           // Hors scope (opacity 0.3)

// Fonctions principales
getNodeHighlightState(nodeId, selection, commonAncestors, visibleNodes, graph)
getNodeOpacity(nodeId, selection, commonAncestors, visibleNodes)
getEdgeOpacity(fromId, toId, selection, highlightedEdges, visibleNodes)
getHighlightedEdges(selection, visibleNodes, graph)
```

**Styles prÃ©dÃ©finis:**
```typescript
HIGHLIGHT_STYLES = {
  selected: { opacity: 1.0, strokeWidth: 3 },
  common_ancestor: { opacity: 1.0, strokeWidth: 2, strokeDasharray: '4,2', highlight: 'yellow' },
  direct_relation: { opacity: 0.9, strokeWidth: 2 },
  visible: { opacity: 0.6, strokeWidth: 1 },
  hidden: { opacity: 0.3, strokeWidth: 1 },
}
```

---

### 4. `SelectionControls.tsx`

**Panneau UI affichant la sÃ©lection courante:**

```tsx
<SelectionControls
  selection={selection}
  selectionMode={selectionMode}
  commonAncestorsCount={commonAncestors.size}
  animals={animals}
  onClear={clearSelection}
/>
```

**Affichage:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ‘¤ SÃ©lection          [Ã—]  â”‚
â”‚ â€¢ Dieureuf                 â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ Clic â†’ SÃ©lection unique    â”‚
â”‚ Ctrl+Clic â†’ Multi-select   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Pour multi-select:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ‘¥ 5 animaux sÃ©lectionnÃ©s [Ã—] â”‚
â”‚ â€¢ Animal A                 â”‚
â”‚ â€¢ Animal B                 â”‚
â”‚ â€¢ Animal C                 â”‚
â”‚ + 2 autres                 â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ ğŸ”— 2 ancÃªtres communs      â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ Clic â†’ Unique              â”‚
â”‚ Ctrl+Clic â†’ Multi          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§ª TESTS MANUELS

### Test 1: Construction du graphe

```typescript
const animals = [
  { id: 'A', sireId: 'B', damId: 'C' },
  { id: 'B', sireId: 'D', damId: 'E' },
  { id: 'C', sireId: 'F', damId: 'G' },
];

const graph = buildPedigreeGraph(animals);

// VÃ©rifie:
graph.ancestors.get('A') === Set(['B', 'C'])
graph.descendants.get('B') === Set(['A'])
```

### Test 2: AncÃªtres communs

```typescript
// Cousins germains (mÃªmes grands-parents)
const ids = ['Cousin1', 'Cousin2'];
const common = findCommonAncestors(ids, graph);

// Doit retourner: Set(['GrandPÃ¨re', 'GrandMÃ¨re'])
```

### Test 3: NÅ“uds visibles (sÃ©lection uniqu)

```typescript
const selection = new Set(['AnimalX']);
const visible = getVisibleNodes(selection, graph, 5);

// Doit inclure:
// - AnimalX
// - Ses parents, grands-parents (5 gÃ©nÃ©rations)
// - Ses enfants, petits-enfants
```

### Test 4: Highlight states

```typescript
// SÃ©lection: A, B
// AncÃªtre commun: C
const stateA = getNodeHighlightState('A', selection, commonAncestors, visible, graph);
// â†’ 'selected'

const stateC = getNodeHighlightState('C', selection, commonAncestors, visible, graph);
// â†’ 'common_ancestor'

const stateD = getNodeHighlightState('D', selection, commonAncestors, visible, graph);
// Si parent de A â†’ 'direct_relation'
```

---

## ğŸ“Š COMPLEXITÃ‰S

**Espace:**
- `PedigreeGraph`: O(n) oÃ¹ n = nombre d'animaux
- `Set<string>` sÃ©lection: O(k) oÃ¹ k = animaux sÃ©lectionnÃ©s

**Temps:**
- `buildPedigreeGraph`: O(n)
- `getAncestors`: O(n) worst case (tout le graphe)
- `findCommonAncestors`: O(k Ã— n) oÃ¹ k = sÃ©lection.size
- `getVisibleNodes`: O(k Ã— n)
- `getNodeHighlightState`: O(k) vÃ©rification sÃ©lection

**Optimisation future:**
- Memoization des rÃ©sultats (useMemo)
- Cache des ancÃªtres communs
- Index par gÃ©nÃ©ration

---

## ğŸ¯ RÃˆGLES PRD V1 IMPLÃ‰MENTÃ‰ES

âœ… **"Un seul moteur de rendu"**  
â†’ Pas encore intÃ©grÃ© mais fondations prÃªtes

âœ… **"SÃ©lection = mode de navigation"**  
â†’ Hook `usePedigreeSelection` prÃªt

âœ… **"Vue = fonction(sÃ©lection)"**  
â†’ Algorithmes `getVisibleNodes` prÃªts

âœ… **"AncÃªtres communs mis en Ã©vidence"**  
â†’ `findCommonAncestors` + highlight system prÃªts

âœ… **"AttÃ©nuation hors sÃ©lection"**  
â†’ SystÃ¨me opacity dans `pedigreeHighlight` prÃªt

---

## ğŸš€ PROCHAINES Ã‰TAPES

### Sprint 2: Layout Multi-Root (2h)

Fichiers Ã  modifier:
1. `pedigreeLayout.ts` - Extend pour multi-root
2. `animalsToPedigree.ts` - Accepter N roots

**Objectif:**
```typescript
// AVANT
computeLayout(singleRoot, config)

// APRÃˆS
computeLayout(selectionIds[], allAnimals, config)
```

### Sprint 3: Canvas Integration (3h)

Fichiers Ã  crÃ©er/modifier:
1. Refactor `FamilyTree.tsx` â†’ `PedigreeCanvas.tsx`
2. IntÃ©grer sÃ©lection + highlight
3. GÃ©rer clics avec/sans Ctrl

### Sprint 4: Orchestration (2h)

CrÃ©er `PedigreeViewer.tsx`:
- Charge tous animaux
- GÃ¨re sÃ©lection
- Passe tout Ã  `PedigreeCanvas`
- Affiche `SelectionControls`

---

## ğŸ“ NOTES TECHNIQUES

### Choix de design:

**1. Set<string> pour sÃ©lection**
- Avantage: Lookup O(1), add/delete O(1)
- InconvÃ©nient: Pas d'ordre (mais pas nÃ©cessaire)

**2. Map bidirectionnelle (ancestors + descendants)**
- Permet traversÃ©e dans les 2 sens
- Efficace pour dÃ©tection ancÃªtres communs

**3. BFS au lieu de DFS**
- GÃ©nÃ©ration par gÃ©nÃ©ration
- Limite facile via `maxGenerations`
- Ã‰vite rÃ©cursion excessive

**4. Ã‰tat highlight calculÃ©, pas stockÃ©**
- Recalcul Ã  chaque render (via useMemo)
- Source de vÃ©ritÃ© = sÃ©lection
- Pas de sync state

---

## ğŸ› BUGS CONNUS

Aucun pour l'instant (code non intÃ©grÃ©).

---

## âœ… VALIDATION

- [x] Code compilÃ© sans erreurs TypeScript
- [x] Types cohÃ©rents
- [x] Pas de dÃ©pendances circulaires
- [ ] Tests unitaires (TODO Sprint 6)
- [ ] Tests integration (TODO Sprint 6)

---

*Sprint 1 terminÃ©! Fondations solides pour le systÃ¨me de sÃ©lection V1.*
