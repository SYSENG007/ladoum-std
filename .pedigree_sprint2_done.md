# Pedigree V1 â€” Sprint 2: Layout Multi-Root

**Date:** 1er janvier 2026, 15:45  
**Status:** âœ… TERMINÃ‰  
**DurÃ©e:** ~15 minutes

---

## ðŸŽ¯ OBJECTIFS SPRINT 2

Ã‰tendre le systÃ¨me de layout pour supporter N roots (sÃ©lection multiple):
1. âœ… Fonction `computeMultiRootLayout()`
2. âœ… Calcul gÃ©nÃ©ration relative Ã  sÃ©lection
3. âœ… IntÃ©gration avec graph algorithms
4. âœ… Support vue globale (0 sÃ©lection), simple (1), groupÃ©e (N)

---

## ðŸ“¦ LIVRABLE: `pedigreeLayout.ts` (Extended)

### Nouvelle fonction principale:

```typescript
computeMultiRootLayout(
  selection: Set<string>,      // Animaux sÃ©lectionnÃ©s
  allAnimals: Animal[],         // Tous les animaux du troupeau
  maxGenerations: number = 5,   // Profondeur ancÃªtres/descendants
  config: LayoutConfig          // Configuration visuelle
): LayoutResult
```

**Workflow:**

```
1. buildPedigreeGraph(allAnimals)
   â†“
2. getVisibleNodes(selection, graph, maxGen)
   â†“
3. Filter allAnimals â†’ visibleAnimals
   â†“
4. Convert to PedigreeSubject[] avec generation relative
   â†“
5. computeLayout({ subjects })
   â†“
6. Return LayoutResult
```

---

## ðŸ”„ ALGORITHMES AJOUTÃ‰S

### 1. `calculateRelativeGeneration()`

**ProblÃ¨me:** Avec N roots, quelle est la "gÃ©nÃ©ration" de chaque nÅ“ud?

**Solution:**
- SÃ©lectionnÃ©s â†’ GÃ©nÃ©ration 0 (centre)
- AncÃªtres â†’ GÃ©nÃ©ration positive (1, 2, 3... vers le haut)
- Descendants â†’ GÃ©nÃ©ration nÃ©gative (-1, -2, -3... vers le bas)

**Exemple:**
```
SÃ©lection: [Animal A, Animal B]

Grand-pÃ¨re A â†’ gen +2
PÃ¨re A       â†’ gen +1
Animal A     â†’ gen  0  â† SÃ‰LECTIONNÃ‰
Enfant A     â†’ gen -1

Grand-pÃ¨re B â†’ gen +2
PÃ¨re B       â†’ gen +1
Animal B     â†’ gen  0  â† SÃ‰LECTIONNÃ‰
Enfant B     â†’ gen -1
```

**ImplÃ©mentation:**
```typescript
function calculateRelativeGeneration(
  animalId, 
  selection, 
  graph
) {
  // SÃ©lectionnÃ©?
  if (selection.has(animalId)) return 0;
  
  // AncÃªtre d'un sÃ©lectionnÃ©?
  for (const selectedId of selection) {
    if (getAncestors(selectedId).has(animalId)) {
      return calculateGenerationDistance(selectedId, animalId, 'up');
    }
  }
  
  // Descendant d'un sÃ©lectionnÃ©?
  for (const selectedId of selection) {
    if (getDescendants(selectedId).has(animalId)) {
      return -calculateGenerationDistance(selectedId, animalId, 'down');
    }
  }
  
  return 0;
}
```

---

### 2. `calculateGenerationDistance()`

**But:** Calculer la distance en gÃ©nÃ©rations entre 2 animaux.

**Algorithme:** BFS (Breadth-First Search)

```typescript
function calculateGenerationDistance(
  fromId, 
  toId, 
  graph, 
  direction: 'up' | 'down'
) {
  const queue = [{ id: fromId, distance: 0 }];
  const visited = new Set();
  
  while (queue.length > 0) {
    const { id, distance } = queue.shift();
    
    if (id === toId) return distance;  // TrouvÃ©!
    if (visited.has(id)) continue;
    visited.add(id);
    
    // Traverser parents ('up') ou enfants ('down')
    const nextIds = direction === 'up' 
      ? graph.ancestors.get(id)
      : graph.descendants.get(id);
    
    for (const nextId of nextIds) {
      queue.push({ id: nextId, distance: distance + 1 });
    }
  }
  
  return 0; // Pas trouvÃ©
}
```

**ComplexitÃ©:** O(n) oÃ¹ n = taille du sous-graphe explorÃ©

---

## ðŸŽ¨ CAS D'USAGE

### Cas 1: Vue Globale (selection.size === 0)

```typescript
const layout = computeMultiRootLayout(
  new Set(),           // Pas de sÃ©lection
  allAnimals,
  5,
  config
);

// RÃ©sultat:
// - Tous les animaux visibles
// - GÃ©nÃ©ration calculÃ©e depuis... tous les roots
// - Layout en forÃªt complÃ¨te
```

**Comportement:**
- `getVisibleNodes(new Set())` â†’ retourne TOUS les IDs
- Tous animaux visibles Ã©gale opacitÃ©
- Pas de highlight

---

### Cas 2: Vue Individuelle (selection.size === 1)

```typescript
const layout = computeMultiRootLayout(
  new Set(['AnimalX']),
  allAnimals,
  5,
  config
);

// RÃ©sultat:
// - AnimalX Ã  gÃ©nÃ©ration 0 (centre)
// - Ses parents/grands-parents (gen +1, +2...)
// - Ses enfants/petits-enfants (gen -1, -2...)
```

**Visuel:**
```
      GP1        GP2
       |          |
       +----+-----+
            |
          PÃ¨re (gen +1)
            |
        AnimalX (gen 0) â† SÃ‰LECTIONNÃ‰
            |
        Enfant1 (gen -1)
```

---

### Cas 3: Vue GroupÃ©e (selection.size > 1)

```typescript
const layout = computeMultiRootLayout(
  new Set(['A', 'B', 'C']),
  allAnimals,
  5,
  config
);

// RÃ©sultat:
// - A, B, C Ã  gÃ©nÃ©ration 0
// - Leurs ancÃªtres COMBINÃ‰S
// - AncÃªtres communs dÃ©tectables
```

**Visuel:**
```
     GrandPÃ¨re Commun (gen +2)
           |
      +----+----+
      |         |
    PÃ¨re A   PÃ¨re B (gen +1)
      |         |
      A         B      C (gen 0) â† SÃ‰LECTIONNÃ‰S
```

---

## âš™ï¸ INTÃ‰GRATION AVEC SPRINT 1

**Utilise les fonctions de `pedigreeGraph.ts`:**
- âœ… `buildPedigreeGraph()` - Construction graph
- âœ… `getVisibleNodes()` - Filtrage visibilitÃ©
- âœ… `getAncestors()` - Calcul distance
- âœ… `getDescendants()` - Calcul distance

**Compatible avec `pedigreeHighlight.ts`:**
- Layout gÃ©nÃ¨re `LayoutNode[]` avec positions
- Highlight system applique styles selon sÃ©lection
- Pas de couplage tight

---

## ðŸŽ¯ RÃˆGLES PRD IMPLÃ‰MENTÃ‰ES

âœ… **"Un seul moteur de layout"**  
â†’ `computeLayout()` rÃ©utilisÃ© par `computeMultiRootLayout()`

âœ… **"Vue = fonction(sÃ©lection)"**  
â†’ `computeMultiRootLayout(selection, ...)` implÃ©mente Ã§a

âœ… **"Pas de gÃ©nÃ©ration implicite"**  
â†’ Seuls les ancÃªtres/descendants rÃ©els affichÃ©s

âœ… **"DonnÃ©es minimales (id, name, sireId, damId)"  
â†’ Aucune dÃ©pendance reproduction/morpho

---

## ðŸ§ª TESTS THÃ‰ORIQUES

### Test 1: SÃ©lection vide

```typescript
const layout = computeMultiRootLayout(new Set(), animals, 5);

// VÃ©rifie:
layout.nodes.length === animals.length  // Tous visibles
```

### Test 2: SÃ©lection unique avec pedigree complet

```typescript
// Animal avec 2 parents, 4 grands-parents, 2 enfants
const layout = computeMultiRootLayout(new Set(['X']), animals, 3);

// VÃ©rifie:
// - 1 (X) + 2 parents + 4 GP + 2 enfants = 9 nodes
layout.nodes.length === 9

// X est Ã  gÃ©nÃ©ration 0
layout.nodes.find(n => n.id === 'X').generation === 0
```

### Test 3: GÃ©nÃ©ration nÃ©gative (descendants)

```typescript
const layout = computeMultiRootLayout(new Set(['Parent']), animals, 2);

const child = layout.nodes.find(n => n.id === 'Child');
child.generation === -1  // Descendant direct
```

### Test 4: SÃ©lection multiple - ancÃªtre commun

```typescript
// Cousins germains
const layout = computeMultiRootLayout(
  new Set(['Cousin1', 'Cousin2']), 
  animals, 
  3
);

const grandpa = layout.nodes.find(n => n.id === 'GrandPa');
grandpa.generation === 2  // 2 gÃ©nÃ©rations au-dessus
```

---

## ðŸ“Š PERFORMANCES

**ComplexitÃ© `computeMultiRootLayout`:**

```
buildPedigreeGraph:         O(n)
getVisibleNodes:            O(k Ã— n) oÃ¹ k = selection.size
calculateRelativeGeneration: O(k Ã— n) par nÅ“ud
  Ã— m nÅ“uds visibles       = O(k Ã— n Ã— m)
computeLayout:              O(m log m)

Total worst-case: O(k Ã— n Ã— m)
```

**Optimisation future:**
- Memoization relative generation
- Cache graph construction
- Paralleliser calculs

**Limites pratiques:**
- n (animaux): ~1000 â†’ OK
- k (sÃ©lection): ~10 â†’ OK
- m (visibles): ~100 â†’ OK
- **Temps attendu:** < 100ms

---

## ðŸš€ PROCHAINES Ã‰TAPES

### Sprint 3: Canvas Integration (3h)

**Objectifs:**
1. Refactor `FamilyTree.tsx` pour utiliser `computeMultiRootLayout`
2. IntÃ©grer sÃ©lection (hook + highlight)
3. GÃ©rer clics (simple / Ctrl+clic)
4. Appliquer opacitÃ©s selon highlight state

**Fichiers Ã  modifier:**
- `FamilyTree.tsx` â†’ accepter `selection` prop
- `PedigreeNode.tsx` â†’ gÃ©rer sÃ©lection visuelle + onClick
- IntÃ©grer `SelectionControls.tsx`

---

## ðŸ“ NOTES TECHNIQUES

### Choix Design:

**1. GÃ©nÃ©ration relative, pas absolue**
- SÃ©lectionnÃ©s toujours au centre (gen 0)
- Adaptatif selon sÃ©lection
- Layout stable visuellement

**2. RÃ©utilisation `computeLayout()`**
- DRY (Don't Repeat Yourself)
- Moins de bugs
- Un seul endroit pour amÃ©liorer layout

**3. BFS pour distance**
- Plus simple que Bellman-Ford
- Garantit plus court chemin (graphe non-pondÃ©rÃ©)
- Terminaison garantie

**4. Conversion Animal â†’ PedigreeSubject**
- Layer d'abstraction propre
- `computeLayout` n'a pas besoin de connaÃ®tre `Animal`
- Facilite tests unitaires

---

## âœ… VALIDATION

- [x] Code compilÃ© sans erreurs
- [x] Imports corrects (pedigreeGraph)
- [x] Types cohÃ©rents
- [ ] Tests unitaires (TODO Sprint 6)
- [ ] Tests integration (TODO Sprint 3)

---

*Sprint 2 terminÃ©! Le systÃ¨me de layout supporte maintenant 0, 1, ou N animaux sÃ©lectionnÃ©s.*
